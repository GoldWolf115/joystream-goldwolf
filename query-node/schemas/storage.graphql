"Global storage system parameters"
type StorageSystemParameters @entity {
  "Blacklisted content hashes"
  blacklist: [String!]

  # TODO: Consider if parameters like:
  # dataObjectFeePerMB,
  # storageBucketBagsLimit,
  # storageBucketsVoucherMaxLimits,
  # etc.
  # are needed here (they can be easily queried from the node)
}

type StorageBucketOperatorStatusMissing @variant {
  _phantom: Int
}

type StorageBucketOperatorStatusInvited @variant {
  workerId: Int!
}

type StorageBucketOperatorStatusActive @variant {
  workerId: Int!
}

union StorageBucketOperatorStatus = StorageBucketOperatorStatusMissing | StorageBucketOperatorStatusInvited | StorageBucketOperatorStatusActive

type GeoCoordinates @entity {
  latitude: Float!
  longitude: Float!

  "Optional DistributionBucketFamilyMetadata reference in case the coordinates are part of a region boundary"
  boundarySourceBucketFamilyMeta: DistributionBucketFamilyMetadata
}

type NodeLocationMetadata @entity {
  "ISO 3166-1 alpha-2 country code (2 letters)"
  countryCode: String

  "City name"
  city: String

  "Geographic coordinates"
  coordinates: GeoCoordinates
}

type StorageBucketOperatorMetadata @entity {
  "Root node endpoint"
  nodeEndpoint: String

  "Optional node location metadata"
  nodeLocation: NodeLocationMetadata

  "Additional information about the node/operator"
  extra: String
}

type StorageBucket @entity {
  "Runtime bucket id"
  id: ID!

  "Current bucket operator status"
  operatorStatus: StorageBucketOperatorStatus!

  "Storage bucket operator metadata"
  operatorMetadata: StorageBucketOperatorMetadata

  "Whether the bucket is accepting any new storage bags"
  acceptingNewBags: Boolean!

  "Bags assigned to be stored by the bucket"
  storedBags: [StorageBag!] @derivedFrom(field: "storedBy")

  "Bucket's data object size limit in bytes"
  dataObjectsSizeLimit: BigInt!

  "Bucket's data object count limit"
  dataObjectCountLimit: BigInt!

  # TODO: Are those useful for storage node?
  # "Currently stored (assigned) data objects size"
  # storedObjectsSize: BigInt!

  # "Currently stored (assigned) objects count"
  # storedObjectsCount: BigInt!
}

type StorageBagOwnerCouncil @variant {
  _phantom: Int
}

type StorageBagOwnerWorkingGroup @variant {
  workingGroupId: String
}

type StorageBagOwnerMember @variant {
  memberId: Int
}

type StorageBagOwnerChannel @variant {
  channelId: Int
}

# Note: Not supported by runtime yet
type StorageBagOwnerDAO @variant {
  daoId: Int
}

union StorageBagOwner = StorageBagOwnerCouncil | StorageBagOwnerWorkingGroup | StorageBagOwnerMember | StorageBagOwnerChannel | StorageBagOwnerDAO

type StorageBag @entity {
  "Storage bag id"
  id: ID!

  "Data objects in the bag"
  objects: [StorageDataObject!] @derivedFrom(field: "storageBag")

  "Storage buckets assigned to store the bag"
  storedBy: [StorageBucket!]

  "Distribution buckets assigned to distribute the bag"
  distributedBy: [DistributionBucket!]

  "Owner of the storage bag"
  owner: StorageBagOwner!
}

type StorageDataObject @entity {
  "Data object runtime id"
  id: ID!

  "Whether the data object was uploaded and accepted by the storage provider"
  isAccepted: Boolean!

  # TODO: Is this useful for storage node?
  # "A reward for the data object deletion"
  # deletionPrize: BigInt!

  "Data object size in bytes"
  size: BigInt!

  "Storage bag the data object is part of"
  storageBag: StorageBag!

  # TODO: Use "Bytes" for better optimalization?
  "IPFS content hash"
  ipfsHash: String!

  # TODO: Use "Bytes" for better optimalization?
  "Public key used to authenticate the uploader by the storage provider"
  authenticationKey: String
}

type DistributionBucketFamilyMetadata @entity {
  "Name of the geographical region covered by the family (ie.: us-east-1)"
  region: String

  "Optional, more specific description of the region covered by the family"
  description: String

  "Optional region boundary as geocoordiantes polygon"
  boundary: [GeoCoordinates!] @derivedFrom(field: "boundarySourceBucketFamilyMeta")
}

type DistributionBucketOperatorMetadata @entity {
  "Root distributor node api endpoint"
  nodeEndpoint: String

  "Optional node location metadata"
  nodeLocation: NodeLocationMetadata

  "Additional information about the node/operator"
  extra: String
}

enum DistributionBucketOperatorStatus {
  INVITED,
  ACTIVE
}

type DistributionBucketOperator @entity {
  "{bucketId}-{workerId}"
  id: ID!

  "Related distirbution bucket"
  distributionBucket: DistributionBucket!

  "ID of the distribution group worker"
  workerId: Int!

  "Current operator status"
  status: DistributionBucketOperatorStatus!

  "Operator metadata"
  metadata: DistributionBucketOperatorMetadata
}

type DistributionBucket @entity {
  "Runtime bucket id"
  id: ID!

  "Distribution family the bucket is part of"
  family: DistributionBucketFamily!

  "Distribution bucket operators (either active or invited)"
  operators: [DistributionBucketOperator!] @derivedFrom(field: "distributionBucket")

  "Whether the bucket is accepting any new bags"
  acceptingNewBags: Boolean!

  "Whether the bucket is currently distributing content"
  distributing: Boolean!

  "Bags assigned to be distributed by the bucket"
  distributedBags: [StorageBag!] @derivedFrom(field: "distributedBy")
}

type DistributionBucketFamily @entity {
  "Runtime bucket family id"
  id: ID!

  "Current bucket family metadata"
  metadata: DistributionBucketFamilyMetadata

  "Distribution buckets belonging to the family"
  buckets: [DistributionBucket!] @derivedFrom(field: "family")
}
