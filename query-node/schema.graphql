enum Network {
  BABYLON
  ALEXANDRIA
  ROME
  OLYMPIA
}

"The decision of the storage provider when it acts as liaison"
enum LiaisonJudgement {
  "Content awaits for a judgment"
  PENDING,

  "Content accepted"
  ACCEPTED,

  "Content rejected"
  REJECTED,
}

"Manages content ids, type and storage provider decision about it"
type DataObject @entity {
  "Content owner"
  owner: DataObjectOwner!

  "Content added at"
  addedAt: Int!

  "Content type id"
  typeId: Int!

  "Content size in bytes"
  size: BigInt!

  "Storage provider id of the liaison"
  liaisonId: BigInt!

  "Storage provider as liaison judgment"
  liaisonJudgement: LiaisonJudgement!

  "IPFS content id"
  ipfsContentId: String!

  "Joystream runtime content"
  joystreamContentId: String!
}

"Owner type for storage object"
union DataObjectOwner = DataObjectOwnerMember
  | DataObjectOwnerChannel
  | DataObjectOwnerDao
  | DataObjectOwnerCouncil
  | DataObjectOwnerWorkingGroup

"Asset owned by a member"
type DataObjectOwnerMember @variant {
  # use `BigInt` instead of `Membership` before variant relations are featured in Hydra
  #"Member identifier"
  #memberId: Membership!
  "Member identifier"
  member: BigInt!

  "Variant needs to have at least one property. This value is not used."
  dummy: Int
}

"Asset owned by a channel"
type DataObjectOwnerChannel @variant {
  # use `BigInt` instead of `Channel` before variant relations are featured in Hydra
  #"Channel identifier"
  #channel: Channel!
  "Channel identifier"
  channel: BigInt!

  "Variant needs to have at least one property. This value is not used."
  dummy: Int
}

"Asset owned by a DAO"
type DataObjectOwnerDao @variant {
  "DAO identifier"
  dao: BigInt!
}

"Asset owned by the Council"
type DataObjectOwnerCouncil @variant {
  "Variant needs to have at least one property. This value is not used."
  dummy: Int
}

"Asset owned by a WorkingGroup"
type DataObjectOwnerWorkingGroup @variant {
  #"Working group identifier"
  #workingGroup: BigInt!

  "Variant needs to have at least one property. This value is not used."
  dummy: Int
}

enum MembershipEntryMethod {
  PAID
  INVITED
  GENESIS
}

type MemberMetadata @entity {
  "Member's name"
  name: String

  "Avatar data object"
  avatar: DataObject

  "Short text chosen by member to share information about themselves"
  about: String
}

"Stored information about a registered user"
type Membership @entity {
  "MemberId: runtime identifier for a user"
  id: ID!

  "The unique handle chosen by member"
  handle: String! @unique @fulltext(query: "membersByHandle")

  "Member's metadata"
  metadata: MemberMetadata!

  "Member's controller account id"
  controllerAccount: String!

  "Member's root account id"
  rootAccount: String!

  "Block number when member was registered"
  registeredAtBlock: Int!

  "Timestamp when member was registered"
  registeredAtTime: DateTime!

  "How the member was registered"
  entry: MembershipEntryMethod!

  "Whether member has been verified by membership working group."
  isVerified: Boolean!

  "Staking accounts bounded to membership."
  boundAccounts: [String!]

  "Current count of invites left to send."
  inviteCount: Int!

  "All members invited by this member."
  invitees: [Membership!] @derivedFrom(field: "invitedBy")

  "A member that invited this member (if any)"
  invitedBy: Membership

  "All members referred by this member"
  referredMembers: [Membership!] @derivedFrom(field: "referredBy")

  "A member that referred this member (if any)"
  referredBy: Membership

  "Whether member is founding member."
  isFoundingMember: Boolean!
}

type MembershipSystemSnapshot @entity {
  "Block number of the snapshot block"
  snapshotBlock: Int!

  "Time of the snapshot (based on block timestamp)"
  snapshotTime: DateTime!

  "Initial invitation count of a new member."
  defaultInviteCount: Int!

  "Current price to buy a membership."
  membershipPrice: BigInt!

  "Percentage of tokens diverted to invitor."
  referralCut: Int!

  "The initial, locked, balance credited to controller account of invitee."
  invitedInitialBalance: BigInt!
}

# Membership-related events

enum EventType {
  # Memberships
  MembershipBought,
  MemberInvited,
  MemberProfileUpdated,
  MemberAccountsUpdated,
  MemberVerificationStatusUpdated,
  ReferralCutUpdated,
  InvitesTransferred,
  MembershipPriceUpdated,
  InitialInvitationBalanceUpdated,
  LeaderInvitationQuotaUpdated,
  InitialInvitationCountUpdated,
  StakingAccountAddedEvent,
  StakingAccountConfirmed,
  StakingAccountRemoved,
  # Working Groups
  OpeningAdded,
  AppliedOnOpening,
  OpeningFilled,
  LeaderSet,
  WorkerRoleAccountUpdated,
  LeaderUnset,
  WorkerExited,
  TerminatedWorker,
  TerminatedLeader,
  StakeSlashed,
  StakeDecreased,
  StakeIncreased,
  ApplicationWithdrawn,
  OpeningCanceled,
  BudgetSet,
  WorkerRewardAccountUpdated,
  WorkerRewardAmountUpdated,
  StatusTextChanged,
  BudgetSpending,
}

type Event @entity {
  "{blockNumber}-{indexInBlock}"
  id: ID!

  "Hash of the extrinsic which caused the event to be emitted"
  inExtrinsic: String

  "Blocknumber of a block in which the event was emitted."
  inBlock: Int!

  "Index of event in block from which it was emitted."
  indexInBlock: Int!

  "Type of the event"
  type: EventType!
}

# FIXME: Warthog bug

# interface WorkingGroupsEvent @entity {
#   "Generic event data"
#   event: Event!
# }

# interface MembershipEvent @entity {
#   "Generic event data"
#   event: Event!
# }


type MembershipBoughtEvent @entity {
  "Generic event data"
  event: Event!

  "New membership created."
  newMember: Membership!

  "New member root account in SS58 encoding."
  rootAccount: String!

  "New member controller in SS58 encoding."
  controllerAccount: String!

  "New member handle."
  handle: String!

  "New member metadata"
  metadata: MemberMetadata!

  "Referrer member."
  referrer: Membership
}

type MemberInvitedEvent @entity {
  "Generic event data"
  event: Event!

  "Inviting member."
  invitingMember: Membership!

  "New membership created."
  newMember: Membership!

  "New member root account in SS58 encoding."
  rootAccount: String!

  "New member controller in SS58 encoding."
  controllerAccount: String!

  "New member handle."
  handle: String!

  "New member metadata"
  metadata: MemberMetadata!
}

type MemberProfileUpdatedEvent @entity {
  "Generic event data"
  event: Event!

  "Membership being updated."
  member: Membership!

  "New member handle. Null means no new value was provided."
  newHandle: String

  "New member metadata. (empty values inside metadata mean no new value was provided)"
  newMetadata: MemberMetadata!
}

type MemberAccountsUpdatedEvent @entity {
  "Generic event data"
  event: Event!

  "Membership in question."
  member: Membership!

  "New member root account in SS58 encoding. Null means no new value was provided."
  newRootAccount: String

  "New member controller in SS58 encoding. Null means no new value was provided."
  newControllerAccount: String
}

type MemberVerificationStatusUpdatedEvent @entity {
  "Generic event data"
  event: Event!

  "Membership in question."
  member: Membership!

  #"TODO: Worker updating status"
  #worker: Worker!

  "New status."
  isVerified: Boolean!
}

type ReferralCutUpdatedEvent @entity {
  "Generic event data"
  event: Event!

  "New cut value."
  newValue: Int!
}

type InvitesTransferredEvent @entity {
  "Generic event data"
  event: Event!

  "Membership sending invites."
  sourceMember: Membership!

  "Membership receiving invites."
  targetMember: Membership!

  "Number of invites transferred."
  numberOfInvites: Int!
}

type MembershipPriceUpdatedEvent @entity {
  "Generic event data"
  event: Event!

  "The new membership price."
  newPrice: BigInt!
}

type InitialInvitationBalanceUpdatedEvent @entity {
  "Generic event data"
  event: Event!

  "New initial invitation balance."
  newInitialBalance: BigInt!
}

type LeaderInvitationQuotaUpdatedEvent @entity {
  "Generic event data"
  event: Event!

  "New quota."
  newInvitationQuota: Int!
}

type InitialInvitationCountUpdatedEvent @entity {
  "Generic event data"
  event: Event!

  "New initial invitation count for members."
  newInitialInvitationCount: Int!
}

type StakingAccountAddedEvent @entity {
  "Generic event data"
  event: Event!

  "Membership in question."
  member: Membership!

  "New staking account in SS58 encoding."
  account: String!
}

type StakingAccountConfirmedEvent @entity {
  "Generic event data"
  event: Event!

  "Membership in question."
  member: Membership!

  "New staking account in SS58 encoding."
  account: String!
}

type StakingAccountRemovedEvent @entity {
  "Generic event data"
  event: Event!

  "Membership in question."
  member: Membership!

  "New staking account in SS58 encoding."
  account: String!
}






type WorkerStatusActive @variant {
  # No additional information needed
  _phantom: Int
}

type WorkerStatusLeft @variant {
  # TODO: Variant relationships
  # TODO: This is not yet emitted by runtime
  workerLeftEventId: ID!

  # Set when the unstaking period is finished
  workerExitedEventId: ID
}

type WorkerStatusTerminated @variant {
  # TODO: Variant relationship
  terminatedWorkerEventId: ID!

  # Set when the unstaking period is finished
  workerExitedEventId: ID
}


union WorkerStatus = WorkerStatusActive | WorkerStatusLeft | WorkerStatusTerminated

# Working Groups
type Worker @entity {
  "The group that the worker belongs to"
  group: WorkingGroup!

  "Worker membership"
  membership: Membership!

  "Worker's role account"
  roleAccount: String!

  "Worker's reward account"
  rewardAccount: String!

  "Worker's staking account"
  stakeAccount: String!

  "Current worker status"
  status: WorkerStatus!

  "Whether the worker is also the working group lead"
  isLead: Boolean!

  "Current role stake (in JOY)"
  stake: BigInt!

  "All related reward payouts"
  payouts: [WorkerPayoutEvent!] @derivedFrom(field: "worker")

  # TODO: should we use createdAt for consistency / doesn't Hydra actually require us to override this field?
  "Blocknumber of the block the worker was hired at"
  hiredAtBlock: Int!

  "Time the worker was hired at"
  hiredAtTime: DateTime!

  "The event that caused the worker to be hired"
  entry: OpeningFilledEvent!

  "Related worker entry application"
  application: WorkingGroupApplication!

  "Worker's storage data"
  storage: String
}

type WorkingGroupMetadata @entity {
  "Status name"
  name: String!

  "Status message"
  message: String

  "Working group about text"
  about: String

  "Working group description text"
  description: String

  "Blocknumber of the block at which status was set"
  setAtBlock: Int!

  "The time at which status was set"
  setAtTime: DateTime!
}

type WorkingGroup @entity {
  "Working group runtime id"
  id: ID!

  "Working group name"
  name: String!

  "Working group current metadata"
  status: WorkingGroupMetadata

  "Current working group leader"
  leader: Worker

  "Workers that currently belong to the group or belonged to the group in the past"
  workers: [Worker!] @derivedFrom(field: "group")

  "All openings related to this group"
  openings: [WorkingGroupOpening!] @derivedFrom(field: "group")

  "Current working group budget (JOY)"
  budget: BigInt!

  # ...
}

type OpeningStatusCancelled @variant {
  # TODO: Variant relationships
  openingCancelledEventId: ID!
}

type OpeningStatusOpen @variant {
  # No additional information needed
  _phantom: Int
}

type OpeningStatusFilled @variant {
  # TODO: Variant relationships
  openingFilledEventId: ID!
}

union WorkingGroupOpeningStatus = OpeningStatusOpen | OpeningStatusFilled | OpeningStatusCancelled

enum WorkingGroupOpeningType {
  REGULAR
  LEADER
}

type WorkingGroupOpeningMetadata @entity {
  "Opening short description"
  shortDescription: String!

  "Opening description (md-formatted)"
  description: String!

  "Expected max. number of applicants that will be hired"
  hiringLimit: Int!

  "Expected time when the opening will close"
  expectedEnding: DateTime!

  "Md-formatted text explaining the application process"
  applicationDetails: String!

  "List of questions that should be answered during application"
  applicationFormQuestions: [ApplicationFormQuestion!]! @derivedFrom(field: "openingMetadata")
}

type WorkingGroupOpening @entity {
  "Opening runtime id"
  id: ID!

  "Related working group"
  group: WorkingGroup!

  "List of opening applications"
  applications: [WorkingGroupApplication!] @derivedFrom(field: "opening")

  "Type of the opening (Leader/Regular)"
  type: WorkingGroupOpeningType!

  "Current opening status"
  status: WorkingGroupOpeningStatus!

  "Opening metadata"
  metadata: WorkingGroupOpeningMetadata!

  "Role stake amount"
  stakeAmount: BigInt!

  "Role stake unstaking period in blocks"
  unstakingPeriod: Int!

  "Initial workers' reward per block"
  rewardPerBlock: BigInt!

  "Blocknumber of opening creation block"
  createdAtBlock: Int!

  "Time of opening creation"
  createdAt: DateTime!
}

type ApplicationStatusPending @variant {
  # No additional information needed
  _phantom: Int
}

type ApplicationStatusAccepted @variant {
  # TODO: Variant relationships
  openingFilledEventId: ID!
}

type ApplicationStatusRejected @variant {
  # TODO: Variant relationships
  openingFilledEventId: ID!
}

type ApplicationStatusWithdrawn @variant {
  # TODO: Variant relationships
  applicationWithdrawnEventId: ID!
}


union WorkingGroupApplicationStatus = ApplicationStatusPending | ApplicationStatusAccepted | ApplicationStatusRejected | ApplicationStatusWithdrawn

type WorkingGroupApplication @entity {
  "Application runtime id"
  id: ID!

  "Related working group opening"
  opening: WorkingGroupOpening!

  "Applicant's membership"
  applicant: Membership!

  "Application stake"
  stake: BigInt!

  "Applicant's initial role account"
  roleAccount: String!

  "Applicant's initial reward account"
  rewardAccount: String!

  "Applicant's initial staking account"
  stakingAccount: String!

  "Answers to application form questions"
  answers: [ApplicationFormQuestionAnswer!] @derivedFrom(field: "application")

  "Current application status"
  status: WorkingGroupApplicationStatus!

  "Blocknumber of application creation block"
  createdAtBlock: Int!

  "Time of application creation"
  createdAt: DateTime!
}

type ApplicationFormQuestionAnswer @entity {
  "Related application"
  application: WorkingGroupApplication!

  "The question beeing answered"
  question: ApplicationFormQuestion!

  "Applicant's answer"
  answer: String!
}

enum ApplicationFormQuestionType {
  TEXT
  TEXTAREA
}

type ApplicationFormQuestion @entity {
  "Related opening metadata"
  openingMetadata: WorkingGroupOpeningMetadata!

  "The question itself"
  question: String!

  "Type of the question (UI answer input type)"
  type: ApplicationFormQuestionType!

  "Index of the question"
  index: Int!
}

type OpeningAddedEvent @entity {
  "Generic event data"
  event: Event!

  "Related group"
  group: WorkingGroup!

  "Related opening"
  opening: WorkingGroupOpening!

  # Other opening data like: metadata, type, staking policy, reward etc. is immutable, so can be read directly from Opening entity
  # TODO: Can it stay like this or are we expecting to introduce updateable openings in the future?
}

type AppliedOnOpeningEvent @entity {
  "Generic event data"
  event: Event!

  "Related group"
  group: WorkingGroup!

  "Related opening"
  opening: WorkingGroupOpening!

  "The application that was created"
  application: WorkingGroupApplication!

  # Same as with opening - application parameters are immutable and can be fetched from Application entity
  # TODO: Can it stay like this or are we expecting to introduce updateable applications in the future?
}

type OpeningFilledEvent @entity {
  "Generic event data"
  event: Event!

  "Related group"
  group: WorkingGroup!

  "Related opening"
  opening: WorkingGroupOpening!

  "Workers that have been hired as a result of filling the opening"
  workersHired: [Worker!] @derivedFrom(field: "entry")
}

type LeaderSetEvent @entity {
  "Generic event data"
  event: Event!

  "Related group"
  group: WorkingGroup!

  "Related Lead worker"
  worker: Worker!
}

type WorkerRoleAccountUpdatedEvent @entity {
  "Generic event data"
  event: Event!

  "Related group"
  group: WorkingGroup!

  "Related worker"
  worker: Worker!

  "New role account"
  newRoleAccount: String!
}

type LeaderUnsetEvent @entity {
  "Generic event data"
  event: Event!

  "Related group"
  group: WorkingGroup!
}

type WorkerExitedEvent @entity {
  "Generic event data"
  event: Event!

  "Related group"
  group: WorkingGroup!

  "Related worker"
  worker: Worker!
}

type TerminatedWorkerEvent @entity {
  "Generic event data"
  event: Event!

  "Related group"
  group: WorkingGroup!

  "Related worker"
  worker: Worker!

  "Slash amount (if any)"
  penalty: BigInt

  "Optional rationale"
  rationale: String
}

type TerminatedLeaderEvent @entity {
  "Generic event data"
  event: Event!

  "Related group"
  group: WorkingGroup!

  "Related worker"
  worker: Worker!

  "Slash amount (if any)"
  penalty: BigInt

  "Optional rationale"
  rationale: String
}

type StakeSlashedEvent @entity {
  "Generic event data"
  event: Event!

  "Related group"
  group: WorkingGroup!

  "Related worker"
  worker: Worker!

  "Balance that was requested to be slashed"
  requestedAmount: BigInt!

  "Balance that was actually slashed"
  slashedAmount: BigInt!

  "Optional rationale"
  rationale: String
}

type StakeDecreasedEvent @entity {
  "Generic event data"
  event: Event!

  "Related group"
  group: WorkingGroup!

  "Related worker"
  worker: Worker!

  "The amount of JOY the stake was decreased by"
  amount: BigInt!
}

type StakeIncreasedEvent @entity {
  "Generic event data"
  event: Event!

  "Related group"
  group: WorkingGroup!

  "Related worker"
  worker: Worker!

  "The amount of JOY the stake was increased by"
  amount: BigInt!
}

type ApplicationWithdrawnEvent @entity {
  "Generic event data"
  event: Event!

  "Related group"
  group: WorkingGroup!

  "Related application"
  application: WorkingGroupApplication!
}

type OpeningCanceledEvent @entity {
  "Generic event data"
  event: Event!

  "Related group"
  group: WorkingGroup!

  "Related opening"
  opening: WorkingGroupOpening!
}

type BudgetSetEvent @entity {
  "Generic event data"
  event: Event!

  "Related group"
  group: WorkingGroup!

  "New working group budget"
  newBudget: BigInt!
}

type WorkerRewardAccountUpdatedEvent @entity {
  "Generic event data"
  event: Event!

  "Related group"
  group: WorkingGroup!

  "Related worker"
  worker: Worker!

  "New reward account"
  newRewardAccount: String!
}

type WorkerRewardAmountUpdatedEvent @entity {
  "Generic event data"
  event: Event!

  "Related group"
  group: WorkingGroup!

  "Related worker"
  worker: Worker!

  "New worker reward per block"
  newRewardPerBlock: BigInt!
}

# TODO: Should we rename the event/extrinsic in the runtime?
type StatusTextChangedEvent @entity {
  "Generic event data"
  event: Event!

  "Related group"
  group: WorkingGroup!

  "New working group metadata"
  metadata: WorkingGroupMetadata!
}

type BudgetSpendingEvent @entity {
  "Generic event data"
  event: Event!

  "Related group"
  group: WorkingGroup!

  "Reciever account address"
  reciever: String!

  "Amount beeing spent"
  amount: BigInt!

  "Optional rationale"
  rationale: String
}

enum PayoutType {
  "Standard reward payout"
  STANDARD_REWARD
  "Return of the previously missed reward"
  RETURN_MISSED
}

# TODO: This will be either based on the actual runtime event or be just a custom query-node event generated of preBlock/postBlock
type WorkerPayoutEvent @entity {
  "Type of the worker payout"
  type: PayoutType

  "Related worker"
  worker: Worker!

  "Amount recieved"
  recieved: BigInt!

  "Amount missed (due to, for example, empty working group budget)"
  missed: BigInt!
}
